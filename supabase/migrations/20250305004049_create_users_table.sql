create table users (
  id uuid primary key references auth.users(id) not null,
  email text unique not null,
  type text default 'USER' check(
    type in ('USER', 'ADMIN')
  ),
  avatar_url text not null,
  created_at timestamp not null default current_timestamp
);

create or replace function public.handle_new_user() returns trigger as $$
  begin
    if new.raw_user_meta_data->>'avatar_url' is null or new.raw_user_meta_data->>'avatar_url' = '' then
      new.raw_user_meta_data = jsonb_set(new.raw_user_meta_data, '{avatar_url}', to_jsonb('https://api.adorable.io/avatars/285/' || new.email || '.png'));
    end if;
    insert into public.users(id, email, avatar_url)
    values (new.id, new.email, new.raw_user_meta_data->>'avatar_url');
    return new;
  end;
$$ language plpgsql security definer;


create or replace trigger on_auth_user_created
  after insert on auth.users for each row
  execute procedure public.handle_new_user();


alter table users enable row level security;


create policy "Enable read access for all authenticated users"
  on users as permissive for select to authenticated
  using (true);


create table category (
  id bigint primary key generated by default as identity,
  created_at timestamp not null default current_timestamp,
  name text unique not null,
  image_url text not null,
  slug text not null,
  products int8[]
);


alter table category enable row level security;

create policy "Enable insert for admins only"
  on category for insert to authenticated
  with check (
    (SELECT type from public.users WHERE id = auth.uid()) = 'ADMIN'
  );

create policy "Enable update for admins only"
  on category for update to authenticated
  using (
    (SELECT type from public.users WHERE id = auth.uid()) = 'ADMIN'
  )
  with check (
    (SELECT type from public.users WHERE id = auth.uid()) = 'ADMIN'
  );

create policy "Enable Delete from Admins only"
  on category for delete to authenticated
  using (
    (SELECT type from public.users WHERE id = auth.uid()) = 'ADMIN'
  );

create policy "Enable Read for all authenticated users"
  on category for select to authenticated
  using (true);


create table product (
  id bigint primary key generated by default as identity,
  created_at timestamp not null default current_timestamp,
  title text unique not null,
  slug text unique not null,
  images_url text[] not null,
  price int8 not null,
  hero_image text not null,
  category bigint references category(id) not null,
  max_quantity int8 not null
);

alter table product enable row level security;


create policy "Enable read access for all users"
  on product as permissive for select to authenticated
  using (true);

create policy "Enable insert for admins only"
  on product for insert to authenticated
  with check (
    (SELECT type from public.users WHERE id = auth.uid()) = 'ADMIN'
  );

create policy "Enable update for admins only"
  on product for update to authenticated
  using (
    (SELECT type from public.users WHERE id = auth.uid()) = 'ADMIN'
  )
  with check (
    (SELECT type from public.users WHERE id = auth.uid()) = 'ADMIN'
  );

create policy "Enable delete for admins only"
  on product for delete to authenticated
  using (
    (SELECT type from public.users WHERE id = auth.uid()) = 'ADMIN'
  );

-- Set up Storage
insert into storage.buckets (id, name)
  values ('app-images', 'app-images');

create policy "Authenticated users can select" on storage.objects
  for select to authenticated using (bucket_id = 'app-images');
create policy "Authenticated users can insert" on storage.objects
  for insert to authenticated with check (bucket_id = 'app-images');
create policy "Authenticated users can update" on storage.objects
  for update to authenticated using (bucket_id = 'app-images');
create policy "Authenticated users can delete" on storage.objects
  for delete to authenticated using (bucket_id = 'app-images');

create table "public"."order" (
  id bigint primary key generated by default as identity,
  created_at timestamp not null default current_timestamp,
  status text not null,
  description text,
  "user" uuid references auth.users(id) not null,
  slug text not null unique,
  total_price float8 not null
);
alter table "public"."order" enable row level security;

create policy "Allow all operations for auth users" 
  on "public"."order" for all to authenticated
  using (true)
  with check (true);

create table "public"."order_item" (
  id bigint primary key generated by default as identity,
  created_at timestamp not null default current_timestamp,
  product bigint references product(id) not null,
  "order" bigint references "public"."order"(id) not null,
  quantity int8 not null
);
alter table "public"."order_item" enable row level security;

create policy "Allow all operations for auth users" 
  on "public"."order_item" for all to authenticated
  using (true)
  with check (true);
